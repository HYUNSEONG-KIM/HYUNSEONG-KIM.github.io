---
layout: default
title: GSL 디자인 문서
parent: GSL 과학계산 라이브러리
grand_parent: Books
nav_order: 1
use_math: true
---

GSL
{: .label }
C
{: .label .label-grey}
Kor
{: label .label-blue}
Writing
{: .label .label-red}

{:toc}

본 문서는 Mark Galassi, James Theiler and Brian Gough 저 [GNU Scientific Library -- Design document](https://www.gnu.org/software/gsl/design/gsl-design_toc.html)입니다.

과학자와 공학자들이 수치해석 소프트웨어나 모듈을 개발할 때, 다음과 같은 라이브러리의 필요성이 대두되어왔습니다. 

* 자유롭게 사용이 가능해 사람들이 라이브러리의 사용, 재배포와 수정을 할 수 있을 것(자유는 공짜의 의미가 아닙니다.).
* 현대적인 코딩, 호출, 스코프 규약을 따라 작성된 C 라이브러리.
*  정갈하고 교육적인 문서; 가급적 TeXinfo로 작성된 문서. 이는 온라인 베포 및 TeX 변환에 매우 용이합니다.
*   고품질의 최신 알고리즘들의 포함.
*   `autoconf`와 `automake`를 사용해, 손쉬운 이식성과 구성.
*   *GNUlitically correct*인 라이브러리

*GNUlitically correct*은 GNU 코딩 규약을 따르고 *autoconf*를 사용하는 프로그램을 뜻합니다.(\*)

기존의 수치 해석 라이브러리들을 사용할 수도 있지만 해당 라이브러리들은 다음과 같은 장단점이 있습니다.

|<center>라이브러리</center>| 설명|
|:--:|:--|
|[***Netlib***](http://www.netlib.org/)|Netlib는 AT&T에서 관리하는 라이브러리로, 인터넷상에서 가장 발전된 수치해석 알고리즘입니다. 불행히도, 대부분의 소프트웨어가 포트란으로 작성되어 있어 대다수의 상황에서 낮선 호출 규약을 사용해야하고, 매우 파편화되어 있어 Netlib의 사용에 큰 노력이 필요합니다.|
|[***GAMS***](http://gams.nist.gov/)|GAMS는 잘 조직된 과학 계산 소프트웨어들의 집합체입니다. 하지만, Netlib와 같이, 각각의 기능들마다 구현체의 질과 문서화 수준이 매우 천차만별입니다.|
|***Numerical Recipes***<br>(http://www.nr.com, http://cfata2.harvard.edu/nr/)|Numerical Recipes는 명확한 방법으로 알고리즘들을 잘 설명하는 훌륭한 책입니다. 하지만, 이 책의 저자는 해당 서적에 있는 코드의 사용은 허용하고 있으나, 재배포에 제약이 있습니다. 따라서 Numerical Recipes는 자유롭지 않습니다. 무엇보다도, 해당 책의 코드 구현체는 포트란스럽다(*Fortrannitis*)는 평과 다른 한계들이 있습니다. [Reviews of Numerical Recipes](https://www.lysator.liu.se/c/num-recipes-in-c.html)|
|***SLATEC***|SLATEC는 1970년도 Department of Energy program에서 작성된 수치 해석 소프트웨어들의 대규모 집합체입니다.  해당 소프트웨어들은 퍼블릭 도메인으로 배포되고 있습니다. 각각의 기능들은 잘 검증되어 있고 잘 짜여진 구조를 가지고 있습니다(그 시기 한계가 있기는 합니다.). GSL은 현대적인 SLATEC를 목적으로 하고 있습니다.|
|***NSWC***|NSWC는 Naval Surface Warfare Center numerical library의 약자입니다. 이 라이브러리는 퍼블릭 도메인으로 배포되는 고수준의 대규모 포트란 라이브러리입니다. 이 라이브러리는 문서를 찾기가 매우 힘듭니다. 출판본의 일부 복사본이 확인되었을 뿐입니다.|
|***NAG*와 *IMSL***|NAG와 IMSL는 모두 상업적으로 판매되는 고수준의 수치 해석 라이브러리입니다. NAG 라이브러리는 IMSL보다 더 많은 기능과 발전된 형태를 가지고 있습니다. IMSL 라이브러리는 편의성에 더 치우쳐져있고,  기본 인자들을 광범위한 가변 인자 배열을 사용해 에뮬레이트합니다.|
|***ESSL*와 *SCSL***|ESSL와 SCSL는 각각 IBM과 SGI에서 상업적으로 판매하는 라이브러리입니다.|
|[***Forth Scientific Library***](http://www.taygeta.com/fsl/sciforth.html)|Forth Scientific Library는 Forh 사용자들만을 대상으로 합니다.|
***Numerical Algorithms with C***|Numerical Algorithms with C, G. Engeln-Mullges, F. Uhlig는 서적과 함께 제공되는 ANSI C로 짜인 훌륭한 수치 해석 라이브러리입니다. 코드 사용이 가능하지만, 라이브러리는 자유 소프트웨어가 아닙니다.|
|***NUMAL***|NUMAL 라이브러리의 C 버전은 H.T. Lau에 의해 작성되었으며, "A Numerical Library in C for Scientists and Engineers" 제목의 책과 디스크로 출판되었습니다. 코드 사용이 가능하지만, 라이브러리는 자유 소프트웨어가 아닙니다.|
|***C Mathematical Function Handbook***|C Mathematical Function Handbook by Louis Baker는 "Handbook of Mathematical Functions" by Abramowitz and Stegun의 수학 함수들에 대응되는 근사와 C 구현체 라이브러리입니다. 코드 사용이 가능하지만, 라이브러리는 자유 소프트웨어가 아닙니다.|
|***CCMATH***|CCMATH_ by Daniel A. Atkinson 는 GSL과 비슷한 범주를 다루는 C로 짜인 수치해석 라이브러리입니다. 코드가 간결한 장점이 있습니다. 초기 버전은 GPL 라이센스 하에서 배포되었지만, 불행히도 최근 버전은 LGPL로 바뀌었습니다.|
| ***CEPHES***|CEPHES는 C로 짜인 고품질의 특수 함수 구현체 모음입니다. GPL 라이센스가 아닙니다.|
|***WNLIB***|WNLIB는 소규모의 수치 해석 C 구현체의 집합입니다. Will Naylor가 작성했으며, 퍼블릭 도메인입니다.|
|***MESHACH***|MESHACH는 C로 짜인 포괄적인 행렬-벡터 선행 대수 라이브러리입니다. 자유롭게 사용가능하나 GPL은 아닙니다.|
|***CERNLIB***|CERNLIB는 대규모의 고품질 포트란 라이브러리로 CERN에서 개발되어 많은 세월동안 사용되었습니다. 본래 비자유 소프트웨어였으나 최근 GPL 라이센스로 베포되고 있습니다.|
|***COLT***|COLT는 자바로 작성된 자유로은 수치 해석 라이브러리로 CERN에서 Wolfgang Hoschek가 작성했습니다. 이  라이브러리는 BSD 형태의 라이센스 하에 베포됩니다.|

GSL 라이브러리는 실제 수치 해석 전문가(나 그들의 대학원생)가 기여할 틀을 제공하는 것을 장기적인 목표로 삼고 있습니다.

## 기여

GSL 팀은 라이브러리의 기능을 강화해 줄 수 있는 새 기여자를 언제나 환영하고 있습니다. 일반적으로 중점을 두는 일들은, 라이브러리 내 함수들의 안전성, 라이브러리의 일관성과 보고된 버그 수정들 입니다. 잠재적 기여자들은 GSL 사바나 페이지 버그 추적기에 나열된 버그들을 조사하고 수정해 라이브러리에 먼저 익숙해지는 것을 권장합니다. 

많은 양의 새 코드를 추가하는 일은 라이브러리의 다른 부분들과 완성도 면에서 많은 차이를 추가하기 때문에 어렵습니다. 라이브러리의 안전성 유지를 위해, 이러한 새 기능들은 GSL 프로젝트 최상단에 패키지로 만들어 개발자가 각각 독립적으로 유지보수하는 것을 권장합니다. 이는 Perl CPAN 아카이브나 TEX CTAN 아카이브등과 같은 자유 소프트웨어 프로젝트에서도 사용하는 방법입니다.

### 패키지(--)


## GSL의 디자인

### 언어
GSL 라이브러리는 **C 언어 하나**만을 사용합니다. 이는 이미 존재하는 컴파일러의 사용이 가능하며, 구조가 간단하고, 손쉽게 범용성을 얻을 수 있는 장점이 있습니다.

### 다른 언어를 위한 인터페이스

다른 언어를 위한 랩핑은 "별도의" 패키지로 제공됩니다. "핵심" 라이브러리 패키지로는 제공되지 않습니다. 해당 랩핑은 각각의 기여자들이 별도 관리합니다.

랩핑을 위한 표준 도구들을 사용하는 것을 권장합니다. swing이나 g-warp가 있습니다.

### 구현하는 기능

존재하는 라이브러리들에 있는 모든 기능을 대상으로합니다. 

### 구현하지 않는 기능

* GPL 라이센스 하에 베포되는 고품질의 패키지에 있는 기능
* 너무 광대한 기능, 하위 기능이 아닌 응용 프로그램 수주을 만드는 것을 의미합니다. 예를 들어, 편미분 방정식(PDE)의 풀이를 위한 기능은 매우 크고 전문화된 응용 프로그램으로 제공되는 경우가 빈번합니다. 이는  매우 다양한 편미분 방정식과 해, 방법들이 존재하기 때문입니다. 이러한 종류의 기능들은 각각 작은 기능들로 분할해서 남겨야합니다. 이런 경우는 사용자들에게 해당하는 좋은 응용 프로그램들을 추천하는 것이 좋습니다.
* 독립적으로 별도 제공되었을 때 유용한 것들, 날짜와 시간등을 조작하는 기능이나, 재정 관련 함수들은 "과학 계산" 라이브러리에 포함될 수 있습니다. 이는 의심할 여지가 없지만, 이러한 모듈은 다른 프로그램들에서도 독립적으로 사용할 수 있어, 별도의 라이브러리 사용이 더 유용합니다.

### 수치해석  라이브러리의 디자인

수치해석 라이브러리의 작성을 할 때, 필연적으로 라이브러리의 **완전성**과 **간결성** 사이에서 갈등하게 됩니다. 완전성은 라이브러리가 "닫혀"있어 서로 다른 객체들에게 작업을 수행할 수 있다는 것을 의미합니다. 수학적 대상은 무한히 많은 방법으로 결합하거나 표현할 수 있습니다. 예를 들어서, 스칼라 필드를 미분해 벡터필드를 표현할 수도 있고, 벡터 필드를 이용해 스칼라 필드를 얻을 수도 있습니다.

 수학 라이브러리를 작성할 때, 무의식적으로 이러한 모든 가능성을 라이브러리로 재현하려는 경향이 있습니다. 이는 기능을 하나씩 추가하면서 점점 뚜렷하게 나타나게 됩니다. 그냥 단순히 하나의 기능만 더 더하면 되는 일이기에 ,하지 않을 이유가 없기 때문입니다.

하지만, 큰 그림을 봅시다. 그 누구도 "모든 가능한 수학 구조와 대상을 C언어로 구조를 이용해 나타내고 싶다."라고 말하지 않습니다. 이러한 전략은 결국 필연적으로 실패하게 됩니다. C와 같은 프로그래밍 언어로 나타낼 수 있는 복잡도는 한계가 있습니다. 이러한 언어에서 수학의 복잡한 구조와 대상을 재현하려는 시도는 결국 유지 보수가 불가능한 코드를 만들어냅니다. 하지만 이러한 경향을 미리 제거하면, 손쉽게 라이브러리의 구현에 실현할 수 있습니다.

완전성보다는 간결성이 더 좋은 선택입니다. 라이브러리 내의 새로운 기능을 디자인할 때, 가능한 한 모듈들이 독립적으로 작동할 수 있도록 작성해야 합니다. 만약, 모듈 간의 상호 의존성이 시도된다면, 어디까지 독립성을 깰지 확실히 정해야 합니다.

### 코드 재사용

라이브러리 전체를 사용할 필요 없이, 각각의 코드파일을 사용자가 만드는 프로그램에 포함할 수 있으면 매우 유용합니다.  이와 같은 독립 실행형 파일이 되도록 하는 것이 권장됩니다. 컴파일 과정에서 당연히, 사용자가 `GSL_ERROR`와 같은 몇몇 매크로들을 정의해야 할 수도 있습니다. 이런 행위까지는 괜찮습니다. 이러한 예시로, 라이브러리 내의 단일 난수 생성기(single random number generator)를 볼 수 있습니다. 


### 표준과 규약

이 프로젝트에 참여하는 사람들은 코딩 표준과 규약을 준수해야합니다. 해당 프로젝트에서는 다음의 표준과 규약들을 따릅니다.

* GNU 코딩 표준
* ANSI 표준 C 라이브러리 규약
* GNU C 라이브러리 규약
* glib GTK 지원 라이브러리 규약

이러한 표준을 위한 참고문헌으로 *GNU Coding Standards* 문서, Harbison and Steels *C: A Reerence Manual*, *GNU, C Library Manual* 그리고 Glib 소스 파일을 볼 수 있습니다.

수학 수식은 Abramowitz & Stegun의 *Handbook of Mathematical Functions*를 따릅니다. 이 책은 수학계에서 자명한 참조 문헌이며, 퍼블릭 도메인으로 사용할 수 있습니다.

본 프로젝트에서 공유하는 정신은 "C로 생각하라" 입니다. 프로젝트가 C로 이루어지기 때문에, C에서 어떤 것이 자연스러운가를 생각해야 합니다. 다른 언어의 특징을 흉내 내기 보다는 C에 집중해야 합니다. 만약, C에서 부자연스러워 다른 언어의 형태로 시물레이션해야한다면, 해당 사항들은 본 프로젝트에서 포함하지 않을 것입니다. 만약, 해당 기능을 없으면 라이브러리에서 특정 기능의 제공이 어렵거나 제한된 버전만 제공한다 하더라도 해당 기능은 제외되어야 합니다. 라이브러리를 지나치게 복잡하게 만드는 일은 가치가 없습니다. 다른 언어들에도 다양한 수치 해석 라이브러리들이 있으며, 해당 언어에서 사용하는 기능이 필요하다면, C 라이브러리를 강제로 사용하는 대신 해당 언어의 라이브러리를 사용하는 것이 현명합니다.

C 가 매크로 어셈블러라는 사실을 항상 기억하는 것이 좋습니다. 만약, 특정 기능이 너무 복잡하다면, 스스로 "이 기능을 매크로-어셈블러로 작성할 수 있는가?"를 생각해보길 바랍니다. 만약, "아니다"라면 해당 기능은  GSL에 포함하지 말아야 합니다.


다음의 논문을 참고해 볼 수 있습니다.

* Kiem-Phong Vo, "The Discipline and Method Architecture for Reusable Libraries", Software - Practice & Experience, v.30, pp.107-128, 2000.

이 논문은 [http://www.research.att.com/sw/tools/sfio/dm-spe.ps](http://www.research.att.com/sw/tools/sfio/dm-spe.ps)에서 찾아보거나, 더 이전의 기술 보고서를  Kiem-Phong Vo, "An Architecture for Reusable Libraries" [http://citeseer.nj.nec.com/48973.html](http://citeseer.nj.nec.com/48973.html)에서 찾아 볼 수 있습니다.

포터블 C 라이브러리 디자인에 관련한 Vmalloc, SFIO 그리고 CDT 논문들이 있습니다.

* Kiem-Phong Vo, "Vmalloc: A General and Efficient Memory Allocator". Software Practice & Experience, 26:1--18, 1996. [http://www.research.att.com/sw/tools/vmalloc/vmalloc.ps](http://www.research.att.com/sw/tools/vmalloc/vmalloc.ps)
* iem-Phong Vo. "Cdt: A Container Data Type Library". Soft. Prac. & Exp., 27:1177--1197, 1997 [http://www.research.att.com/sw/tools/cdt/cdt.ps](http://www.research.att.com/sw/tools/cdt/cdt.ps)
* David G. Korn and Kiem-Phong Vo, "Sfio: Safe/Fast String/File IO", Proceedings of the Summer '91 Usenix Conference, pp. 235-256, 1991. [http://citeseer.nj.nec.com/korn91sfio.html](http://citeseer.nj.nec.com/korn91sfio.html)


소스 코드들은 GNU Coding Standards에 밎추어 탭이 아닌 스페이스만 사용해야 합니다. 예로 `indent` 명령어를 사용해서:

```
indent -gnu -nut *.c *.h
```

`-nut` 옵션은 탭을 스페이스들로 바꾸어줍니다.

### 작업전 확인 사항들

기능을 구현하기 전에 관련 내용들에 관한 철저한 조사가 필요합니다. 이는 장기적으로는 많은 시간을 절약해 줍니다. 가장 중요한 두 가지 단계는 다음과 같습니다.

* 해당 기능이 이미 자유 라이브러리(GPL이나 GPL-호환)에서 제공하는 기능인지 판별하기. 만약, 이미 존재한다면 재구현할 필요 없습니다. Netlib, GAMs, na-net, sci.math.num-analysis, 그리고 일반적인 인터넷에서 조사를 해보아야 합니다. 이러한 과정은 관련성이 있는 기존의 독점 라이브러리 목록도 조사할 수 있습니다. 다음 단계에서 참조할 수 있도록 해당 목록을 기록하는 것을 권장합니다.
* 기존의 상업/자유 라이브러리들의 구현체들에 대한 비교 조사를 수행합니다. 일반적인 API, 프로그램과 하위 기능들간의 통신 방법을 검사하고, 해당 구현체들이 가지거나 가지지 않는 기능들을 조사하니다. 그리고 이들을 관련 핵심 개념과 기능들에 익숙해지도록  분류합니다. 이미 존재하는 라이러리들의 문서 리뷰는 좋은 레퍼런스가 되어주는 것을 잊지 말아야 합니다.
* 해당 주제들을 살펴보고 최신 기술이 무엇인지 파악합니다. 가장 최신의 리뷰 논문들을 찾아보고, 다음의 저널들을 검색해 봅시다.
	-   ACM Transactions on Mathematical Software
	-   Numerische Mathematik
	-   Journal of Computation and Applied Mathematics
	-   Computer Physics Communications
	-   SIAM Journal of Numerical Analysis
	-   SIAM Journal of Scientific Computing

GSL이 연구 프로젝트가 아님을 명심합시다. 좋은 구현체를 만드는 일은, 새로운 알고리즘을 만들지 않더라도 충분히 어려운 작업입니다. 본 프로젝트는 구현 가능하고 존재 가능한 알고리즘의 구현체를 원합니다. 소소한 개선에 시간을 조금 써도 나쁘지는 않지만, 거기에 몰두하지는 말아야합니다.

### 알고리즘의 선택

가능한 한, 잘 확장되는 알고리즘을 고르고 점근적으로 처리를 해야함을 기억해야합니다. 특히 정수 인자가 있는 함수들에서 주의해야 합니다.  Abramowitz & Stegun에서는 재귀적 관계와 같이 함수를 정의하는 데 $O(n)$의 시간 복잡도를 가지는 간단한 알고리즘을 많이 사용하고, 이를 구현하는 데 사용하고 싶을 수 있습니다. 그러나, 이러한 알고리즘은 $n=O(10-100)$에서는 잘 작동할지 몰라도, $n=1000000$인 경우, 원하는 데로 작동하지 않을 것입니다.

비슷하게, 다변량 자료들이 동일한 크기로 조정된 원소들이나 $O(1)$의 복잡도를 가지고 있다고 가정하지 말아야합니다. 알고리즘들은 반드시 내부적으로 필요한 스케일 조정과 균형을 처리해야 하고, 이를 위해 적절한 노름들을 사용해야합니다. (예를 들어, $\|x\|$ 보다는 $\|Dx\|$를 사용하는 것이 좋습니다. $D$는 스케일 조정을 위한 대각 행렬입니다.)

### 문서화

문서화: 프로젝트 관리자는 어떻게 문서화 되는지에 대해 예제를 제공해야합니다. 고품질의 문서화는 반드시 필요한 작업입니다. 각 문서는 주제를 소개하고, 제공하는 함수들에 대해 세심한 참조를 제공해야합니다. 우선 순위는 함수에 대한 좋은 참조 문헌을 제공하는 것이라, 예제를 반드시 문서에 포함시킬 필요는 없습니다.

메뉴얼에 사용될 그래프를 그릴 때, GNU Plotutils와 같은 자유 소프트웨어를 사용해야 합니다.

어떤 그래프들은 gnuplot과 같이 완전히 자유(아니면 GNU) 소프트웨어가 아닌 프로그램으로 만들어질 수도 있고, 선호하는 프로그램으로 만들 수도 있습니다. 이런 그래프들은 GNU plitutils를 사용한 결과물로 교체되어야합니다.

문헌을 참조할 때는 그 분야의 가장 자명하고, 표준적이며 좋은 문헌을 참조해야합니다. 많이 일어나는 일이지만, 덜 알려진 교재나 입문서(예를 들어 학부에서 사용되기 위한)의 참조는 지양해야 합니다. 각 분야의 자명한 참조 문헌의 예로, 알고리즘은 Knuth, 통계학은 Kendall & Stuart, 특수 함수들은 Abramowitz & Stegun (Handbook of Mathematical Functions AMS-55)) 등이 있습니다.

표준 참조 문헌들은 라이브러리 사용자들에게 더 좋은 접근성을 제공해 줍니다. 만약, 이러한 문헌을 사용할 수 없어 사용자가 문헌을 참조하기 위해 서적을 구입해야 한다면, 가능한 한 고품질의 서적을 사용해야 합니다. 고품질의 기준은 GSL 메뉴얼에서 다루는 다른 참조 문헌들을 최대한 많이 다루는  서적을 의미합니다. 서로 다른 책들이 너무나 많이 인용되어 있다면, 알고리즘의 세부 사항들을 보기 위해 문헌을 참조해야 하는 사용자들에게 매우 비효율적이고 비싼 희생을 강요하게 됩니다. 참조 문헌들은 일반적인 대학 교재들 보다 판본이 더 오래 유지되어야 합니다. 대학 교재들은 몇년만에 판본이 바뀌는 경우가 흔합니다.

비슷하게, 될 수 있으면 원 논문을 인용해야합니다. 그리고, 해당 문서들의 복사본은 나중에 사용할 수 있도록 잘 보관하는 것이 좋습니다. 예를 들어 버그 보고나 앞으로 유지 보수에 필요할 수도 있기 때문입니다.

문헌을 찾아보기 위해 도움이 필요하다면, `gsl-discuss` 메일링 리스트에 도움을 청할 수 있습니다. GSL 개발자들이 논문의 복사본을 얻는 것을 돕기 위한 봉사자 집단이 있고, 그들은 좋은 고품질 자료들(도서관)에 접근할 수 있습니다. 

[James Theiler 왈:
그리고, 소프트웨어 문서화에 열과 성을 다할 것을 약속합니다. 이러한 문서화에는 왜 소프트웨어를 사용해야하는지, 정확히 어떤 기능을 하는지, 어떻게 정확한 호출을 할 수 있을지, 대략적으로 어떻게 알고리즘이 작동하는지, 어디서 알고리즘을 얻었는지, 그리고 우리가 작성하지 않은 부분들은 어디서 코드를 얻었느지를 포함할 것입니다. 우리는 모든 패키지를 계산 알고리즘으로 부터 새로 구축하는 것을 추구하지 않습니다. 이러한 재구축 보다는 이미 존재하는 자유롭게 사용가능한 수학 소프트웨어들의 집합체로써 사용되길 원합니다. 또, 우리가 작성하는 이 소프트웨어도 동일하게 사용될 수 있길 바랍니다. ]

### 네임 스페이스

모든 외부 호출용 함수와 변수들은 `gsl_` 접두사를 가집니다.

모든 외부 호출용 메크로들은 `GSL_` 접두사를 가집니다.

모든 외부 호출용 헤더파일들은 접두사 `gsl_`로 시작하는 이름을 가져야 합니다.

설치되는 모든 라이브러리는 `libgslhistogram.a`와 같은 이름을 가져야 합니다.

실행 가능한 모든 설치 프로그램(예를 들어 유틸리티 프로그램들)들은 접두사 `gsl-`을 가져야합니다. (`-` 하이폰(hypen)입니다. `_`(underscore)가 아닙니다.)

모든 함수, 변수 이름등은 소문자로, 매크로와 전처리 변수들은 대문자로 써야합니다.

### 헤더 파일

헤더파일들은 반드시 한 번만 포함되어야 합니다. 이를 idempotent 하다라 부르는데, 예를 들어, 헤더파일의 내용을 전처리 문구로 감싸서 이를 가능하게 할 수 있습니다.

```{.C}
#ifndef __GSL_HISTOGRAM_H__
#define __GSL_HISTOGRAM_H__
...
#endif /* __GSL_HISTOGRAM_H__ */
```

### 대상 시스템

목표로 하는 대상 시스템은 IEEE 대수를 사용하고, 표준 C 라이브러리를 모두 사용가능한 ANSI C 시스템입니다.

### 함수 이름

각각의 모듈 이름들은 그 모듈 안의 함수들 이름에 접두사로 작용합니다. 예를 들어서 `gsl_fft` 모듈에는 `gsl_fft_init` 함수가 있습니다. 모듈들은 라이브러리 소스 트리의 하위 디렉토리들과 대응됩니다.

### 객체 지향성(--)

알고리즘들은 객체 지향적이어야 합니다. 하지만, ANSI C에 잘 규합될 수 있어야합니다.

### 주석(--)

GNU 표준 코딩 규약을 따릅니다. 

### 최소화 된 구조(--)

구조를 최소화하길 바랍니다. 예를 들어서 여러 단계의 알고리즘들로 풀 수 있는 문제가 있다면, 각 경우를 다룰 수 있는 분리된 구조체를 만드는 것이 더 좋습니다. 

### 알고리즘 분해(--)


### 메모리 할당과 소유권(--)


### 메모리 레이아웃(--)


### 선형대수 레벨(--)


### 예외와 오류 관리(--)

### 영속성(--)


### 반환값 사용(--)


### 변수 이름(--)

변수 이름에 다음의 이름 규약들을 사요해야 합니다.

`dim` : 차원의 수.

`w`: 작업 공간을 가르키는 포인터.

`state`: 상태 변수를 가르키는 포인터. ( 문자를 저장해야 한다면, `s`를 사용합시다.) 

`result`: 결과(반환 값) 포인터.

`abserr`: 절대 오차.

`relerr`: 상대 오차.

`epsabs`:

`epsrel`:

`size`: 배열이나, 백터의 크기. 예: `double array[size]`

`stride`: 벡터의 stride

`size1`: 행렬의 행 갯수.

`size2`: 행렬의 열 갯수.

`n`: 일반적인 정수. 예: 배열의 원소 숫자, fft 등등.

`r`: 난수 발생자 (`gsl_rng`).

### 자료형 크기(--)
[^int size]

[^int size]: int 자료형은 구동 플랫폼의 기본 데이터 처리 타입을 따릅니다. 이는 실행 환경에서 가장 빠른 동작을 보장하기 위함입니다. short 같은 자료형이 고정된 byte 크기를 가진 반면, int는 플랫폼에 따라서 다양한데, 어떤 플랫폼에서는 32bit, 64bit 크기를 가지고 어떤 플랫폼에서는 16bit의 크기를 가질 수도 있습니다. 대표적으로 아두이노와 같은 AVR 시스템에서 16bit 크기를 가진 경우가 흔합니다.

### size_t(--)

### 배열 vs 포인터

### 포인터

### 상수화

### Pseudo-templates

### 임의의 상수

### Test suites

### Compilation

### Thread-safety

### 법적 문제


### 비 유닉스 이식성

### 다른 라이브러리와의 호환성

### 병렬 처리

### 정밀도

### 잡다한 사항
