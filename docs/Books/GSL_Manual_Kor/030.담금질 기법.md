---
layout: default
title: 담금질 기법
parent: GSL 과학계산 라이브러리
grand_parent: Books
nav_order: 30
use_math: true
---

GSL
{: .label }
C
{: .label .label-grey}
Kor
{: label .label-blue}


어떤 문제를 풀고자 할 때, 풀고자 하는 공간의 정보가 부족하거나 연속적이지 않으면, 뉴턴 방법과 같은 방법은 사용할 수 없습니다(자코비안 같은 미분 행렬 계산이 필요합니다.). 이언 경우에 확률적 탐색 기법(Stochastic search techiques)를 시도해 볼 수 있습니다. 특히 이 방법들은, 조합적 최적화 (combinatorial optimization) 문제를 푸는 데 빈번히 사용됩니다. 이러한 문제의 예로 외판원 문제 (Salesman problem)이 있습니다.

문제 공간에서 해를 구한다는 것은 실수 값을 가지는 에너지 함수 (비용 함수라고도 합니다.)의 값이 최소화되는 지점을 찾는 것을 의미합니다. 담금질 기법(Simlated annealing)은 지역적 최소화를 피할 수 있어 일반적으로 좋은 결과를 내놓는 최소화 기법입니다. 이 방법의 원리는 온도(temperature)를 낮출 수 있는 무작위 전이를 공간 위에서  진행한다는 것에 있습니다. 각 걸음의 진행 확률은 볼츠만 분포(Boltzmann distribution)에 의해 결정 됩니다.  

이 단원에서 기술된 함수들은 `gsl_siman.h` 헤더파일에 기록되어 있습니다.

## 담금질 알고리즘
담금질 알고리즘은 기본적으로 문제 공간에서 무작위 방향 중 에너지를 최소화하는 경향으로 상태를 확률적으로 바꾸며 해를 탐색합니다. 이러한 전이 확률은 볼츠만 분포(Boltzmann distribution)을 기반으로 결정됩니다.

$$p = e^{-(E_{i+1} - E_i)/(kT)}$$

$E_{i+1} >E_i$인 조건에서 성립하며, $E_{i+1} \leq E_i$인 경우 $p=1$로 정의합니다.

다시 말해,새로운 에너지 단계가 낮으면 전이가 일어나고, 새로운 에너지 단계가 높으면 확률에 기반해 전이가 결정됩니다. 이 확률은 온도 $T$에 비례하고, 에너지 차이 $E_{i+1}-E_i$에  반비례합니다.


온도 $T$는 초기 단계에서 결정되며 일반적으로 적절한 높은 값을 가집니다. 무작위 전이는 이 온도 값에 의존하게 됩니다. 전이 과정에서 온도는 설계된 냉각 절차(cooling schedule)에 따라 천천히 낮아집니다. 예를 들어 $T -> T/ \mu_T$으로 $\mu_T$를 1보다 조금 더 큰 수로 설정해 볼 수 있습니다.

이러한 높은 에너지 상태로 전이할 수 있는 확률의 존재는 다양한 상황에서 담금질 기법이 지역적 최소값에 빠지지 않도록 해, 최적의 값을 찾을 수 있도록 도와줍니다.

## 담금질 함수

>void **gsl_siman_solve** ( const gsl_rng * *r*, void * *x0_p*, gsl_siman_Efunc_t *ef*, <br>
gsl_siman_step_t *take_step*, gsl_siman_metric_t *distance*, <br>
gsl_siman_print_t *print_position*, gsl_siman_copy_t *copyfunc*,			    
gsl_siman_copy_construct_t *copy_constructor*,
gsl_siman_destory_t *destructor*,		    
size_t *element_size*, gsl_siman_params_t *params*)

이 함수는 주어진 공간에서 담금질 기법을 이용해 해를 찾습니다. 공간은 `Ef`와 `distance`로 정의됩니다. 각 전이 단계는 주어진 인자 중 난수 생성자 `r`과 함수 `take_step`에 의해 결정됩니다.

이 계의 시작 조건 설정은 `x0_p`에 의해 주어집니다. 이 명령어 집합은 2개의 방법으로 현재 설정을 갱신하는데, **고정 크기 방법** (fixed-size mode)와 **동적 크기 방법**( variable-size mode)이 있습다.  고정 크기 방법에서는 설정이 메모리 상의 `element_size` 크기의 한 공간에 저장되고, C의 표준 함수 `malloc(), memcpy(), free()` 들에 의해 내부에서 이 설정의 복사본들이 만들어지고, 복사되고, 소멸합니다. 이 고정 크기 방법 상태에서는 함수 포인터 `copyfunc, copy_constructor` 그리고  `destructor`들이 `null` 값을 가지게 됩니다.  반면, 동적 크기 방법에서는 `copyfunc, copy_constructor` 그리고  `destructor`가 `malloc(), memcpy(), free()` 대신에 쓰입니다. 이 경우 `element_size` 값은 0으로 주어집니다.

`params` 구조 변수는 제공된 온도 계획과 수정 가능 한 변수들로 이루어지는 실행을 제어합니다.

종료 시, 알고리즘 과정을 통해 얻어진 최적의 결과가 `x0_p`에 저장됩니다. 만약, 담금질 기법이 성공적이었다면, 이는 문제 공간의 최적점에 대해 좋은 근사를 나타내줍니다.

만약, 함수 포인터 `print_position`이 `NULL` 값이 아니라면, 디버그 기록이 `stdout`에 출력 될 것입니다. 이는 다음과 같은 행을 가집니다:

```bash
#-iter  #-evals  temperature position energy   best_energy  
```

또, 이는 출력 함수 `print_position`에도 스스로 출력 됩니다. 만약, `print_position`이 `NULL`이라면, 아무 값도 출력 되지 않습니다.                         

이 라이브러리의 담금질 알고리즘 명령어 집합은 사용자 정의 함수들을 필요로합니다. 이 정의 함수들은 풀고자 하는 문제 공간과 에너지 함수를 정의합니다. 이러한 함수들을 사용자가 직접 다음의 초안 형태로 정의해 풀고자하는 문제에 적절한 함수들을 알고리즘에 정의할 수 있습니다.


>**gsl_siman_Efunc_t**

이 함수형은 현재 상태 `xp`에 대한 에너지를 반환해야합니다.

```C
double (*gsl_siman_Efunc_t) (void *xp)
```

 >**gsl_siman_step_t**

이 함수형은 현재 상태 `xp`를 난수 발생자 `r`과 단계별 최대 이동거리 `step_size`를 이용해 수정해야합니다.

```C       
void (*gsl_siman_step_t) (const gsl_rng *r, void *xp, double step_size)
```

>**gsl_siman_metric_t**

 이 함수형은 주어진 두 개의 상태 `xp`, `yp` 사이의 거리를 반환해야합니다.

    double (*gsl_siman_metric_t) (void * xp, void * yp)

>**gsl_siman_print_t**

이 함수형은 주어진 상태 `xp` 설정값을 출력해야합니다.

```C
void (*gsl_siman_print_t) (void *xp)
```

>**gsl_siman_copy_t**

 이 함수형은 설정을 `source`에서 `dest`로 복사해야 합니다.

```C
void (*gsl_siman_copy_t) (voi d *souirce, coid *dest)
``` 

 >**gsl_siman_copy_construct_t**

 이 함수형은 설정 `xp`의 새 복사본을 만들어야 합니다.

```C
void (*gsl_siman_copy_construct_t) (void *xp)
```

 >**gsl_siman_destory_t**
 
 이 함수형은 설정 `xp`를 삭제해야 합니다. 다시말해, 메모리에서 풀어주어야 합니다.

```C
void (*gsl_siman_destroy_t) (void *xp)
```

>**gsl_siman_params_t**

 이는 `gsl_siman_solve()`의 실행을 제어하는 인자들입니다. 이 구조체는 탐색, 에너지 함수, 단계 함수와 초기 가정을 제어하는 데 필요한 모든 정보를 담고 있습니다.

|| |
|--|--|
|`int n_tries`|각 단계에서 시도할 지점의 수|
|`int iters_fixed_T`|각 온도별 반복 횟수|
|`double step_size`|각 무작위 전이에서 최대 크기|
|`double k, t_initial, mu_t, t_min`|볼츠만 분포 인자들과 냉각 절차 인자|

## 예제

GSL의 담금질 알고리즘 구현은 그다지 세련된 구현체가 아닙니다. 상당히 원시적인 형태로 구현되어 있죠. 그러나 이는 의도된 사항입니다. 왜냐하면, 이 구현체는 C로 짜서 C에서 호출함을 염두에 두고 개발되었으며, 동시에 다양한 응용 가능성에 목적을 두고 있기 때문입니다. 그렇기에, 여기서 여러분들이 개발하는 응용 프로그램에 약간의 수정을 거쳐 적용할 수 있는 여러 예시들을 제공할 것입니다. 이는 다양한 구현을 좀 더 쉽게 할 수 있도록 도와줄 것입니다.

### Trivial 예제

첫번째 예제로, 1차원 직교 좌표계에서 감쇠하는 sine 함수를 에너지 함수로 둔 상황을 살펴봅시다. 이 공간은 많은 지역적 최소값이 존재합니다. 하지만 전역 최소값은 1개만이 존재하죠. 1.0과 1.5사이에 존재합니다. 초기 추정은 15.5입니다. 전역 최소값으로 부터 사이에 여러 지역적 최소값이 존재하는 지점이죠.

```C
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<gsl/gsl_siman.h>

/* set up parameters for this simulated annealing run */

/* how many points do we try before stepping */
#define NTRIES 200

/* how many iterations for each T? */
#define ITERS_FIXED_T 1000

/* max step size in random walk */
#define STEP_SIZE 1.0

/* Boltzman constant */
#define K 1.0

/* initial temperature */
#define T_INITIAL 0.008

/* damping factor for temperature */
#define MU_T 1.003
#define T_MIN 2.0e-6

gsl_siman_params_t params
    = {N_TRIES, ITERS_FIXED_T, STEP_SIZE,
       K, T_INITIAL, MU_T, T_MIN};
/* now some functions to test in one dimension */
double E1(void *xp){
    double x = * ((double *) xp);
    return exp(-pow((x-1.0),2.0))*sin(8*x);
}

double M1(void *xp, void *yp){
    double x = *((double *) xp);
    double y = *((double *) yp);
    return fabs(x - y);
}

void S1(const gsl_rng * r, void *xp, double step_size){
    double old_x = *((double *) xp);
    double new_x;
    double u = gsl_rng_uniform(r);
    new_x = u * 2 * step_size - step_size + old_x;
    memcpy(xp, &new_x, sizeof(new_x));
}

void P1(void *xp){
    printf ("%12g", *((double *) xp));
}
     
int main(void){
    const gsl_rng_type * T;
    gsl_rng * r;
    double x_initial = 15.5;
    gsl_rng_env_setup();
    T = gsl_rng_default;
    r = gsl_rng_alloc(T);
    gsl_siman_solve(r, &x_initial, E1, S1, M1, P1,
    NULL, NULL, NULL,
    sizeof(double), params);
    gsl_rng_free (r);
    return 0;
}
```

Fig. 15는 `siman_test`를 다음과 같이 실행한 결과입니다.

```bash
$ ./siman_test | awk '!/^#/ {print $1, $4}'
 | graph -y 1.34 1.4 -W0 -X generation -Y position
 | plot -Tps > siman-test.eps
```

Fig. 16는 `siman_test`를 다음과 같이 실행한 결과입니다.

```bash
$ ./siman_test | awk '!/^#/ {print $1, $5}'
 | graph -y -0.88 -0.83 -W0 -X generation -Y energy
 | plot -Tps > siman-energy.eps
```

![Fig. 15](https://www.gnu.org/software/gsl/doc/html/_images/siman-test.png)

**Fig. 15** 담금질 방법 실행 예시: 높은 온도에서(그래프 시작지점)는 해가 여러 값으로 발산하는 것을 볼 수 있습니다. 하지만 낮은 온도에서는 수렴합니다.

![Fig. 16](https://www.gnu.org/software/gsl/doc/html/_images/siman-energy.png)

**Fig. 16** 담금질 방법 에너지 vs 시행 횟수

