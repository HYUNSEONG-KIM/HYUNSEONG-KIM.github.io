---
layout: default
title: 고속 푸리에 변환
parent: GSL 과학계산 라이브러리
grand_parent: Books
nav_order: 18
use_math: true
---

GSL
{: .label }
C
{: .label .label-grey}
Kor
{: label .label-blue}
Writing
{: .label .label-red}


이 단원에서는 고속 푸리에 변환 (FFTs)을 위한 함수들을 기술합니다. 라이브러리에서는 radix-2 방법과 mixed-radix 방법을 사용합니다. 효율성을 위해서 각 기능들은 복소수용 함수와 실수형 함수로 나뉘어져 있습니다. Mixed-radix 함수들은 FFTPACK 라이브러리를 재구현한 형태입니다. FFTPACK의 포트란 코드는 Netlib에서 확인할 수 있습니다(FFTPACK에는 sine, cosine 변환 기능도 제공하지만 `GSL`에서 더이상 제공하지 않습니다.). 본 문서에서 기술되는 알고리즘들에 대한 더 자세한 정보와 파생사항들은 "GSL FFT Algorithms"을 참고할 수 있습니다. (**참조문헌과 추가자료** 참고)

## 수학적 정의

고속 푸리에 변환은 이산 푸리에 변환 (DFT)를 효율적으로 계산하기 위한 알고리즘들을 의미합니다.

$$x_j = \sum_{k=0}^{n-1} z_k e\exp(-2\pi i j k /n)$$

DFT는 연속 푸리에 변환을 근사할 필요가 있을 때 사용됩니다. 일반적으로 공간, 시간에 대해 이산 간격으로 샘플들이 주어졌을 때 사용합니다. 기초적인 이산 푸리에 변환은 행렬-벡터곱 $W \vec{z}$으로 계산됩니다. 일반적인 행렬-곱의 계산 복잡도는 $n$ 개의 데이터에 대해 $O(n^2)$의 복잡도를 가집니다. 고속 푸리에 변환은 분할 정복 전략을 사용해 행렬 $W$를 여러개의 작은 하위-행렬들과 그에 상응하는 길이 $n$의 정수들로 분할해 연산을 수행합니다. $n$이 여러개의 정수들의 곱$f_1 f_2 \dots fm$으로 표현될 수 있다면, DFT는 $O(n \sum f_i)$의 시간 복잡도를 가집니다. radix-2 FFT 방법은 $O(n\log_2 n)$의 복잡도를 갖ㅂ니다.

모든 FFT 함수들은 3가지 형태의 변환을 제공합니다. 변환, 역변환, 그리고 조정 계수가 없는 역변환입니다. 이들은 같은 수학적 정의에 기반해 있습니다. 고속 푸리에 변환은 $x = \text{FFT(z)}$로 다음과 같이 정의됩니다.

$$x_j = \sum_{k=0}^{n-1} z_k \exp(-2\pi ijk /n)$$

역변환은 $x= \text{IFFT}(z)$로 다음과 같이 정의됩니다.

$$z_j = \sum_{k=0}^{n-1} x_k \exp(2\pi ijk /n)$$

계수 $1/n$로 완전한 역변환을 얻을 수 있습니다. 예를 들어서, `gsl_fft_complex_forward()`를 `gsl_fft_complex_inverse()`와 합성하면 완전히 같은 값을 얻을 수 있습니다(수치적 오류는 같이 나올 수 있습니다.)

일반적으로, 변환-역변환 과정에서 지수 함수의 지수 부호를 $\pm$ 중 자유롭게 선택할 수 있습니다. `GSL`에서는 FFTPACK과 같은 규약을 따릅니다. 변환에서는 음의 부호를 역변환에서는 양의 부호를 사용합니다. 이러한 부호 규칙의 이점은 역변환으로 본래의 함수를 다시 만들 수 있다는 점입니다. 반면, `Numerical Recipes`는 부호 규약이 반대입니다. 변환에 양의 부호를 역변환에 음의 부호를 사용합니다.

$$z_j^{backwards} = \sum_{k=0}^{n-1} x_k \exp(2\pi ijk /n)$$

결과물의 구체적인 크기가 중요하지 않을 때, 조정계수가 없는 변환은 역변환에서 불필요한 나눗셈을 줄일 수 있습니다. 


## 복소수 FFTs 개요

복소수 FFT 함수들은 부동 소수점 배열을 입출력에 사용합니다. 이러한 배열은 실수-허수부가 번갈아 할당된 형태로 사용됩니다. 예를 들어서, 다음은 길이 $6$의 복소 FFT 함수 입력용 배열입니다.

    double x[3*2];
    gsl_compleX_packed_array data = x;

이 배열은 $3$개의 복소수 배열 `z[3]`과 같이 사용할 수 있습니다.

    data[0] = Re(z[0])
    data[1] = Re(z[0])
    data[2] = Re(z[1])
    data[3] = Re(z[1])
    data[4] = Re(z[2])
    data[5] = Re(z[2])

배열의 인덱스는 DFT의 수학 정의에 사용된 인덱스와 동일한 순서를 가집니다. 별도의 인덱스 변환을 할 필요가 없습니다.

`strid` 인자는 사용자 함수를 사용할 때, `z[i]` 대신 `z[strode*i]` 형태로 변환을 할 수 있게 해줍니다. $1$보다 큰 이 값은 행렬의 열들에 대해 FFT를 적용할 수 있게 해줍니다. $1$ 값을 가지면, 배열 사이에 건너뛰는 값 없이 변환을 할 수 있습니다.

벡터 인자들에 대해 FFT를 적용할 수 있습니다. 예를 들어 `gsl_vector_complex * v`를 사용하면 다음과 같은 형태로 이 단원의 함수들을 사용할 수 있습니다.

    gsl_complex_packed_array data = v -> data;
    size_t *stride* = v->stride;
    size_t *n* = v->size;

물리학등의 응용에서 기억해 두어야 할 점은, DFT의 인덱스들이 물리적 주파수에 그대로 대응되지는 않는다는 점입니다. 만약 DFT의 시간 간격이 $\Delta$라면, 주파수 공간은 $-1/(2\Delta)$에서 $1/(2\Delta)$로 주파수의 부호가 $\pm$을 모두 가집니다. $+$ 주파수는 배열의 시작 지점에서 중간지점까지, $-$의 주파수는 배열의 끝에서 중간까지 공간에 저장됩니다.

다음은 배열 `data`의 자세한 정보와 대응되는 시간-공간의 $z$, 주파수-공간의 $x$를 나타낸 표입니다.

    index    z               x = FFT(z)

    0        z(t = 0)        x(f = 0)
    1        z(t = 1)        x(f = 1/(n Delta))
    2        z(t = 2)        x(f = 2/(n Delta))
    .        ........        ..................
    n/2      z(t = n/2)      x(f = +1/(2 Delta),
                                   -1/(2 Delta))
    .        ........        ..................
    n-3      z(t = n-3)      x(f = -3/(n Delta))
    n-2      z(t = n-2)      x(f = -2/(n Delta))
    n-1      z(t = n-1)      x(f = -1/(n Delta))

 $n$이 짝수일 때, $n/2$ 지점은 양수와 음수 부호의 주파수 $(+1/(2\Delta), -1/(2\Delta))$ 값을 모두 가집니다. 이 둘은 같습니다. $n$이 홀수라면, 위의 표와 같은 구조를 가집니다. 하지만 $n/2$는 존재하지 않습니다.

## 복소수 Radix-2 FFTs

이 단원에서 서술하는 radix-2 알고리즘은 간단하고 작지만, 가장 효율적인 방법은 아닙니다. 이 방법은 Cooley-Tukey 알고리즘을 이용해서 길이가 $2^m, m \in \mathbb{N}$인 복소수 데이터의 FFTs를 계산합니다. 이때, 해당 배열 외에 다른 저장소가 필요 없습니다. 대응되는 자기 정렬 mixed-radix 방법은 계산 과정에서 별도의 공간을 사용해 더 좋은 효율을 보여줍니다.

이 단원에서 기술하는 모든 함수들은 헤더파일 `gsl_fft_complex.h`에 기술되어 있습니다.

## 복소수 mixed-radix FFTs

>int **gsl_fft_complex_radix2_forward**(gsl_complex_packed_array *data*, size_t *stride*, size_t *n*)<br>
>int **gsl_fft_complex_radix2_transform**(gsl_complex_packed_array *data*, size_t *stride*, size_t *n*, gsl_fft_direction *sign*)<br>
>int **gsl_fft_complex_radix2_backward**(gsl_complex_packed_array *data*, size_t *stride*, size_t *n*)<br>
>int **gsl_fft_complex_radix2_inverse**(gsl_complex_packed_array *data*, size_t *stride*, size_t *n*)<br>

이 함수들은 변환, 역변환, 그리고 조정계수 없는 역변환을 주어진 길이 `n`과 `stride`를 이용해 복소수 배열 `data`에 적용합니다. 이 함수들은 실시간 선택 알고리즘인 radix-2를 사용하며 결과값은 `data`에 그대로 저장됩니다. 배열의 길이 `n`은 반드시 $2^m, m \in \mathbb{N}$여야 합니다. `transform`이 붙은 함수에 관해, `sign` 인자는 `forward` ($+1$)와 `backward`($-1$)을 선택할수 있습니다. 

오류 없이 변환이 정상적으로 완료되면 각 함수들은 `GSL_SUCESS` 값을 반환합니다. 만약 `n`이 $2$의 배수가 아닐 때에는 `GSL_ECOM` 값을 반환합니다.

## 실수 FFTs 개요

실수 값들에 적용하는 고속 푸리에 변환은 복소수인 경우와 비슷하지만, 변환과 역변환에서 중요한 차이가 있습니다. 바로 실수 값들의 푸리에 변환은 실수 값이 아니라는 점입니다. 변환 된 값들은 다음과 같은 대칭성을 가지는 복소 수열로 나타나게 됩니다.

$$z_k = z_{n-k}^*$$

이러한 대칭성을 가지는 수열을 **컬례 복소**(conjugage-complex)나 반 복소성(half-complex)을 가지고 있다고 부릅니다. 이러한 결과물의 구조적 차이점은 변환(실수->반 복소), 역변환(반 복소 -> 실수)에 대해 이전의 복소 푸리에 변환과 다른 설계를 필요로 합니다. 이에 따라, 실수 푸리에 변환의 함수들은 두 개의 범주로 나뉘어 집니다. 실수 배열을 처리하는 `gsl_fft_real` 함수들과 반 복소 배열을 처리하는 `gsl_fft_halfcomplex` 함수들입니다.

`gsl_fft_real` 함수들은 실수 배열의 주파수 계수를 계산합니다. 실수 배열 $x$에 대한, 반 복소 계수 $c$는 푸리에 분석에 따라 다음과 같이 주어집니다.

$$c_k = \sum_{j=0}^{n-1}x_j \exp(-2\pi ijk/n)$$

`gsl_fft_halfcomplex` 함수들은 역변환과 조정 계수 없는 역변환을 계산합니다. 이 함수들은 반 복소 주파수 계수 $c$로 부터 실수 배열을 재구성합니다.

$$x_j = \frac{1}{n}\sum_{k=0}^{n-1}c_k \exp(2 \pi ijk /n)$$

반 복소 배열의 대칭성으로 인해 배열 전체의 절반만 저장해도 됩니다. 나머지 절반은 반 복소 대칭성으로 계산 과정에서 재구성 됩니다. 이 방법은 짝수, 홀수를 가리지 않고 모든 크기에 대해 사용할 수 있습니다. 짝수 크기의 배열에 대해, 중간값 $k/2$도 실수가 됩니다. 따라서 반 복소 배열의 계산에 필요한 것은 `n` 크기의 실수 저장 공간뿐입니다. 계산 결과인 실수 배열도 입력 배열과 같은 크기의 배열에 저장됩니다.

정확한 저장 공간의 관리는 알고리즘에 따라 다릅니다. radix-2와 mixed-radix에 따라 차이가 있습니다. radix-2 방법은 실수와 허수부가 저장되는 위치를 가능한 한 멀리 떨어지게 저장하도록 강제합니다. 반면, mixed-radix 방법은 이러한 제약이 없으며, 실수와 허수부가 인접 위치에 저장합니다. 이는 메모리 접근에서 인접성 향상에 좋습니다.

 
## 실수 Radix-2 FFTs

이 단원은 radix-2 고속 푸리에 변환 알고리즘을 실수 값들에 적용시키는 함수들에 대해 다룹니다. 이들은 Cooley-Tukey 알고리즘을 사용해 $2$의 거듭 제곱 크기의 길이를 가지는 값들에 대해 계산합니다.

이 radix-2 고속 푸리에 변환 함수들은 헤더 파일 `gsl_fft_real.h`에 저장되어 있습니다.

>int **gsl_fft_real_radix2_transform**(double *data*[], size_t *stride*, size_t *n*)

이 함수는 radix-2 고속 푸리에 변환을 주어진 `stride` 간격과 길이 `n`을 가지는 실수 배열 `data`에 대해 계산합니다. 계산 결과는 반 복소 배열로 각 실수-허수 값들은 정해진 위치 규약에 따라 저장됩니다. 길이 $n$의 배열에 대해, $k < n/2$대해, $k$ 번째 복소수의 실수 값은 $k$ 번째 배열에 저장되고, 대응 되는 허수 값은 $n-k$ 번째 배열에 저장됩니다. $k > n/2$인 항들은 대칭성 $z_k = z_{n-k}^*$에 의해 재구성 됩니다. $k=0$이나 $k= n/2$인 경우는 항상 실수가 되며, 따로 처리됩니다. 이들의 실수 값은 $0$과 $n/2$ 위치에 저장되며, 이들의 허수 값은 $0$이므로 따러 저장되지 않습니다. 

다음 표는 어느 실수 배열의 계산 값 `data`와 허수부가 $0$인 동일한 복소수 배열을 이용해 얻은 결과를 비교한 표입니다. (`stride` $= 1$로 가정합니다.)

```
complex[0].real    =    data[0]
complex[0].imag    =    0
complex[1].real    =    data[1]
complex[1].imag    =    data[n-1]
...............         ................
complex[k].real    =    data[k]
complex[k].imag    =    data[n-k]
...............         ................
complex[n/2].real  =    data[n/2]
complex[n/2].imag  =    0
...............         ................
complex[k'].real   =    data[k]        k' = n - k
complex[k'].imag   =   -data[n-k]
...............         ................
complex[n-1].real  =    data[1]
complex[n-1].imag  =   -data[n-1]
```

계산 결과는 나중에 기술될 함수 `gsl_fft_halfcomplex_radix2_unpack()`로 완전한 복소수 배열로 바꿀 수 있습니다.


반 복소 배열을 위한 radix-2 고속 푸리에 변환 함수들은 헤더 파일 `gsl_fft_halfcomplex.h`에 기술되어 있습니다.

>int **gsl_fft_halfcomplex_radix2_inverse**(double *data*[], size_t *stride*, size_t *n*)<br>
>int **gsl_fft_halfcomplex_radix2_backward**(double *data*[], size_t *stride*, size_t *n*)

이 함수들은 radix-2 고속 푸리에 변환의 역변환과 조정 계수 없는 역변환을 주어진 `stride` 간격과 길이 `n`을 가지는 반 복소 배열 `data`에 대해 계산합니다. 이때, `data`는 `gsl_fft_real_radix2()`에서 사용된 결과 배열과 동일한 저장 규칙을 가지고 있습니다. 결과로 나오는 실수 배열은 기본 배열 순서를 따릅니다.

>int **gsl_fft_halfcomplex_radix2_unpack**(const double halfcomplex_coefficient[], gsl_complex_packed_array complex_coefficient, size_t *stride*, size_t *n*)

이 함수는 `gsl_fft_real_radix2_transform()` 함수의 계산 결과로 나오는 `halfcomplex_coefficient` 배열을 일반 복소수 `complex_coefficient` 배열로 변환합니다. 이 함수는 복소수 배열을 대칭성 $z_k = z_{n-k}^*$를 이용해, 중복되는 요소들을 재구성합니다. 알고리즘은 다음과 같습니다.

```C
complex_coefficient[0].real = halfcomplex_coefficient[0];
complex_coefficient[0].imag = 0.0;

for (i = 1; i < n - i; i++)
  {
    double hc_real = halfcomplex_coefficient[i*stride];
    double hc_imag = halfcomplex_coefficient[(n-i)*stride];
    complex_coefficient[i*stride].real = hc_real;
    complex_coefficient[i*stride].imag = hc_imag;
    complex_coefficient[(n - i)*stride].real = hc_real;
    complex_coefficient[(n - i)*stride].imag = -hc_imag;
  }

if (i == n - i)
  {
    complex_coefficient[i*stride].real = halfcomplex_coefficient[(n - 1)*stride];
    complex_coefficient[i*stride].imag = 0.0;
  }
```

## 실수 mixed-radix FFTs

이 단원에서는 실수 값들을 위한 mixed-radix 고속 푸리에 알고리즘을 기술합니다. 고속 푸리에 변환을 위한 mixed-radix 함수들은 모든 크기의 값에 대해 적용할 수 있습니다. 이 함수들은 Paul Swarztrauber가 포트란 FFRPACK 라이브러리에 작성한 실수 고속 푸리에 변환 기능들을 재구현한 형태입니다. 이 알고리즘에 사용된 이론들은 Clive Temperton이 작성한 "Fast Mixed-Radix Real Fourier Transforms"을 참고할 수 있습니다. 이 단원에 작성된 함수들은 FFTPACK에 있는 기반 알고리즘과 같은 인덱스 규약을 가집니다.

이 단원의 함수들은 FFTPACK의 반 복소 배열 저장 규약을 사용합니다. 이 규약에서 실수 배열의 반 복소 변환은 $0$에서 증가하는 순서로, 실수-허수부가 번갈아 이웃해 가며 저장됩니다. 실수로 확인된 값에 대해서는 허수부가 저장되지 않습니다. $0$의 주파수를 가지는 부분에는 허수부가 저장되지 않습니다(). 크기가 짝수인 입력 배열에서는, $n/2$의 허수바가 저장되지 않습니다. 이는 $z_k = z_{n-k}^*$로 인해 자명하게 실수이기 때문입니다.

저장 규약은 다음 예시로 보는 것이 가장 정확합니다. 아래의 표는 $n=5$의 홀수 길이 배열에 대한 계산 결과를 나타냅니다. 각 열은 

>type gsl_fft_real_wavetable<br>
>type gsl_fft_halfcomplex_wavetable

>gsl_fft_real_wavetable * **gsl_fft_real_wavetable_alloc**(size_t *n*)<br>
>gsl_fft_halfcomplex_wavetable * **gsl_fft_halfcomplex_wavetable_alloc**(size_t *n*)

>void **gsl_fft_real_wavetable_free**(gsl_fft_real_wavetable *wavetable)<br>
>void **gsl_fft_halfcomplex_wavetable_free**(gsl_fft_halfcomplex_wavetable *wavetable)

>type gsl_fft_real_workspace

>gsl_fft_real_workspace * **gsl_fft_real_workspace_alloc**(size_t *n*)

>void **gsl_fft_real_workspace_free**(gsl_fft_real_workspace *workspace)

>int **gsl_fft_real_transform**(double *data*[], size_t *stride*, size_t *n*, const gsl_fft_real_wavetable *wavetable, gsl_fft_real_workspace *work)<br>
>int **gsl_fft_halfcomplex_transform**(double *data*[], size_t *stride*, size_t *n*, const gsl_fft_halfcomplex_wavetable *wavetable, gsl_fft_real_workspace *work)

>int **gsl_fft_real_unpack**(const double real_coefficient[], gsl_complex_packed_array complex_coefficient, size_t *stride*, size_t *n*)


>int **gsl_fft_halfcomplex_unpack**(const double halfcomplex_coefficient[], gsl_complex_packed_array complex_coefficient, size_t *stride*, size_t *n*)


## 참조문헌과 추가자료

FFT 입문에 다음의 리뷰 논문을 추천합니다.

* P. Duhamel and M. Vetterli. Fast Fourier transforms: A tutorial review and a state of the art. Signal Processing, 19:259–299, 1990.

`GSL` 구현체에 쓰인 알고리즘을 참고하기 위해서 "GSL FFT Algorithms" 문서를 참조할 수 있습니다(이 문서는 `GSL`라이브러리에 포함되어 있습니다. `doc/fftalgorithms.tex`). 이 문서는 FFT에 관한 일반적인 정보들과 각각의 구현체와 그 알고리즘에 관한 여러 파생 정보들을 기술하고 있습니다. 이에 더해, 관련 참조 문헌들도 함께 제공하고 있습니다. 편의를 위해 중요한 참조문헌들을 이곳에 함께 제공합니다.

FFT를 예시 프로그램과 함께 제공하는 몇몇 입문 서적들이 있습니다. Brigham 저 "The Fast Fourier Transform"과 Burrus and Parks 저 "DFT/FFT and Convolution Algorithms"이 있습니다.

* E. Oran Brigham. “The Fast Fourier Transform”. Prentice Hall, 1974.
* C. S. Burrus and T. W. Parks. “DFT/FFT and Convolution Algorithms”, Wiley, 1984.

이 입문서적들은 radix-2 FFT 방법을 자세히 서술하고 있습니다. FFTPACK 구현체의 핵심 알고리즘인 Mixed-radix 알고리즘은 Clive Temperton의 논문에서 잘 다루ㅜ어져 있습니다.

* Clive Temperton, Self-sorting mixed-radix fast Fourier transforms, Journal of Computational Physics, 52(1):1–23, 1983.

실수 데이터에 관한 FFTs의 파생 정보들은 다음의 두 논문에서 다루고 있습니다.

* Henrik V. Sorenson, Douglas L. Jones, Michael T. Heideman, and C. Sidney Burrus. Real-valued fast Fourier transform algorithms. “IEEE Transactions on Acoustics, Speech, and Signal Processing”, ASSP-35(6):849–863, 1987.
* Clive Temperton. Fast mixed-radix real Fourier transforms. “Journal of Computational Physics”, 52:340–350, 1983.

1979년도에, IEEE에서는 포트란 FFT 프로그램을 중점적으로 리뷰한 개괄 문서을 출판했습니다. 해당 문서는 "Programs for Digital Sigal Processinng"이란 제목으로 여러 다른 FFT 알고리즘들의 구현에 좋은 참조 문헌이 되어줍니다.

* Digital Signal Processing Committee and IEEE Acoustics, Speech, and Signal Processing Committee, editors. Programs for Digital Signal Processing. IEEE Press, 1979.

대규모 데이터에 FFT를 적용할 때, 이러한 작업 전용으로 만들어진 FFTW 라이브러리를 쓰는 것을 추천합니다. 이 라이브러리는 Frigo와 Johnson이 작성했습니다. FFTW 라이브러리는 구동 하드웨어에 맞추어 최고의 효율을 내도록 스스로를 최적화 합니다. 이 라이브러리는 GNU GPL하에서 사용가능합니다.

* FFTW Website, http://www.fftw.org/