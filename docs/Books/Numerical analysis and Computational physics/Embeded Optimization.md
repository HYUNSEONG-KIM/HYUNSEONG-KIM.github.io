---
layout: default
title: Embeded Optimization
parent: Numerical analysis and Computational physics
grand_parent: Books
use_math: true
---

이 단원은 재미로 보길 바랍니다. 임베디드(Embedded)는 말 그대로 특정 시스템의 내장 시스템 등을 말하기 때문에 우리가 흔히 쓰는 x86등의 시스템과는 환경이 매우 차이가 납니다. 때문에 일반적인 프로그램 같이 작성할 경우, 자원의 한계로 구동이 불가능 한 경우도 빈번해, 다양한 최적화 기법을 사용합니다. 이러한 최적화 기법은 해당 시스템에서만 사용 가능한 경우도 많고 x86 시스템에서 사용하면 치명적일 수도 있습니다. 때문에 이 단원을 굳이 읽을 필요는 없습니다. 하지만, C의 여러 기능들을 이해하는 데 도움이 될 수도 있습니다. 공통적으로 활용가능한 최적화는 이미 다른 단원에 첨부하였으므로(대표적으로 실수 연산), 이 아래의 내용은 주로 임베디드 환경에서나 유용한 방법들입니다.

## 표준함수의 대체

## 비트 연산

## 포인터

흔히들 포인터에 대해 오해하는 점이, 주소로 접근하려면 포인터가 필요하다고 생각하는 것입니다. 주변의 C 언어 책을 펼처서 포인터 단원을 보면, 포인터는 **주소**를 저장하는 변수의 선언이라 적혀 있습니다. 우리가 다른 변수에 접근하기 위해 필요한 것은 **주소** 뿐입니다. 때문에 포인터 없이 주소를 직접 써서 접근할 수도 있습니다. 이러한 방법을 메모리에 **직접 접근**한다고 표현합니다. 포인터를 이용한 접근은 **간접 접근**방법입니다. 

예시로 기초적인 포인터 예제를 봅시다.

```C
int a = 1;
int *p = &a;
printf("%d", *p++);
```


만약, 변수의 저장 주소를 알고있다면(`0x300`이라 하자), 다음과 같이 쓸 수 있습니다.

```C
*(int *)0x300 = 1; 
printf("%d", *(int *)0x300++);
```

매크로를 이용하면 포인터와 비슷하게 코드를 보이게 할 수 있다.

```C
#define P (*(int *)0x300)

P = 1;
printf("%d", P++);

```

이 둘은 임베디드 시스템에서 완전히 동일한 기능을 합니다. 이렇게 메모리의 주소를 알고 있다면 직접 주소를 접근하는 데 쓸 수 있습니다. 이러한 방법을 쓰는 데는 **"변수의 저장 주소를 알고 있다."** 라는 점이 매우 중요합니다. 임베디드 시스템에서는 개발자가 변수 사용공간을 전부 관리할 수 있고, 할당 자체도 관리해야하는 경우가 빈번해, 변수와 시스템 전체에 대한 관리가 가능합니다. 하지만 x86에서는 불가능하고 OS 단에서 공간을 알아서 관리합니다. **절대 x86 시스템에서 프로그램을 작성할 때 사용해서는 안됩니다.** 

포인터를 사용한 방법은 1. 포인터 변수 내의 주소를 확인, 2. 주소가 가르키는 위치로 가 연산. 이 두 과정을 거치는 데 반해, 주소를 직접 사용하면 1. 주소가 가르키는 위치로 가 연산 하나로 끝낼 수 있습니다. 임베디드 환경에서는 변수의 내용을 보는 호출마저도 속도에 큰 영향을 주는 경우가 많아서 이러한 방법을 취하기도 합니다. 

다만, 이렇게 내부에 주소 값들이 추가되는 코드들은 프로그램 실행파일의 크기가 증가한다는 단점이 있습니다. 

## `volatile` 한정자

C를 주로 개발에 쓰는 개발자라 하더라도 하드웨어 제어에 큰 관심이 없다면 `volatile`이라는 변수 한정자는 입문서에서 보고 거의 쓰지 않습니다.

## 함수의 호출

## 루프 최적화

## 연산자의 비용

참고 문헌



